<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mixamo GLB Sample - Final Version</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
         #loading { 
             position: absolute; 
             top: 50%; 
             left: 50%; 
             transform: translate(-50%, -50%); 
             font-family: Arial, sans-serif; 
             color: white;
             background: rgba(0,0,0,0.7);
             padding: 20px;
             border-radius: 10px;
             z-index: 1000;
         }
         #controls {
             position: absolute;
             top: 20px;
             left: 20px;
             z-index: 1000;
             font-family: Arial, sans-serif;
         }
         .control_button {
             background: rgba(0,0,0,0.7);
             color: white;
             border: none;
             padding: 10px 15px;
             margin: 5px;
             border-radius: 5px;
             cursor: pointer;
         }
         .control_button:hover {
             background: rgba(0,0,0,0.9);
         }
    </style>
    
    <!-- Import Maps を使用してモジュール解決を設定 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
 <body>
     <div id="loading">Loading Three.js...</div>
     
     <!-- コントロールパネル -->
     <div id="controls" style="display: none;">
         <button class="control_button" onclick="setFrontView()">正面</button>
         <button class="control_button" onclick="setSideView()">真横</button>
         <button class="control_button" onclick="setBackView()">背面</button>
         <br>
         <div style="color: white; margin: 10px 0; font-weight: bold;">2Dフラット化処理:</div>
         <button class="control_button" id="toonBtn" onclick="toggleToonShading()">トゥーン風効果: OFF</button>
         <button class="control_button" id="pixelBtn" onclick="togglePixelation()">ピクセル化: OFF</button>
         <br>
         <button class="control_button" onclick="enablePixelTransition()">ピクセル化トランジション</button>
         <button class="control_button" onclick="resetAllEffects()">全てリセット</button>
         <br>
         <div style="color: white; margin: 10px 0; font-weight: bold;">アニメーション制御:</div>
         <button class="control_button" onclick="toggleAnimation()">アニメーション: ON</button>
         <button class="control_button" onclick="analyzeModel()">モデル分析</button>
         <button class="control_button" onclick="testPoseControl()">ポーズ制御テスト</button>
         <br>
         <div style="color: white; margin: 10px 0; font-weight: bold;">腕のポーズ制御:</div>
         <button class="control_button" onclick="resetPose()">ポーズリセット</button>
         <button class="control_button" onclick="raiseLeftArm()">左腕上げ</button>
         <button class="control_button" onclick="raiseRightArm()">右腕上げ</button>
         <br>
         <button class="control_button" onclick="raiseBothArms()">両腕上げ</button>
         <button class="control_button" onclick="waveLeftArm()">左腕振り</button>
         <button class="control_button" onclick="waveRightArm()">右腕振り</button>
         <br>
         <button class="control_button" onclick="fitToScreen()">画面にフィット</button>
     </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        console.log('Three.js version:', THREE.REVISION);
        
        let scene, camera, renderer, mixer, clock;
        
        // フラット化処理用の変数
        let flatEffects = {
            toonShading: false,
            pixelation: false
        };
        
        // アニメーション制御用の変数
        let isAnimationPlaying = true;
        let currentActions = [];
        
        // ポーズ制御用の変数
        let armBones = {
            leftShoulder: null,
            leftArm: null,
            leftForeArm: null,
            rightShoulder: null,
            rightArm: null,
            rightForeArm: null
        };
        let composer, outlinePass, pixelPass;
        
        function init() {
            // ローディング表示を更新
            document.getElementById('loading').innerHTML = 'Initializing 3D scene...';
            
             // シーン（透明背景）
             scene = new THREE.Scene();
             // 背景を透明に設定

             // カメラ（正面ビュー用に調整）
             camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
             camera.position.set(0, 1, 3); // 正面から見やすい位置

             // レンダラー（透明背景対応）
             renderer = new THREE.WebGLRenderer({ 
                 antialias: true, 
                 alpha: true // 透明背景を有効化
             });
             renderer.setSize(window.innerWidth, window.innerHeight);
             renderer.setClearColor(0x000000, 0); // 完全透明
             
             // CSSのfilter: brightness()のような効果を追加
             renderer.toneMapping = THREE.ACESFilmicToneMapping;
             renderer.toneMappingExposure = 1.5; // 明度を2倍に（brightness(2)相当）
             renderer.outputColorSpace = THREE.SRGBColorSpace;
             
             document.body.appendChild(renderer.domElement);

             // 床と影は削除（コメントアウト）
             // const floor = new THREE.Mesh(...)

             // フラットライティング（デフォルト）- 影なしの均一な照明
             const ambientLight = new THREE.AmbientLight(0xffffff, 2.0); // 非常に明るい環境光のみ
             scene.add(ambientLight);

            // アニメーション用Clock
            clock = new THREE.Clock();

            // ローディング表示を更新
            document.getElementById('loading').innerHTML = 'Loading 3D model...';

            // GLBモデル読み込み
            const loader = new GLTFLoader();
            console.log('GLTFLoader created, loading model...');

             loader.load('./model.glb', function (gltf) {
                 console.log('GLTF loaded successfully:', gltf);
                 const model = gltf.scene;
                 
                 // 元の材質を保存し、色調整のみ行う
                 window.originalMaterials = new Map(); // 元の材質を保存
                 
                 model.traverse(function (child) {
                     if (child.isMesh) {
                         // 元の材質を保存
                         window.originalMaterials.set(child, child.material.clone());
                         
                         // 元の材質の特性を保持しつつ、フラットで明るい見た目に調整
                         if (child.material.isMeshStandardMaterial) {
                             // フラットで明るい見た目に調整
                             child.material.roughness = 1.0; // 完全にマットな質感（光沢を完全に除去）
                             child.material.metalness = 0.0; // 金属感を完全に除去
                             
                         } 
                        //  else if (child.material.isMeshPhongMaterial) {

                        //  }
                         
                         console.log('=== モデル読み込み時の材質情報 ===');
                         console.log('Mesh名:', child.name);
                         console.log('Material type:', child.material.type);
                         console.log('元の色 (RGB):', child.material.color);
                         console.log('元の色 (Hex):', '#' + child.material.color.getHexString());
                         
                         // 色がグレー系かどうかをチェックし、自然な色に変更
                         const color = child.material.color;
                         const isGrayish = Math.abs(color.r - color.g) < 0.1 && Math.abs(color.g - color.b) < 0.1 && Math.abs(color.r - color.b) < 0.1;
                         if (isGrayish && color.r < 0.8) { // 明るいグレー（白に近い）は除外
                             console.warn('⚠️ グレー系の色が検出されました:', child.name, '#' + color.getHexString());
                             
                             // 部位名に基づいて自然な色を適用
                             const name = child.name.toLowerCase();
                             let naturalColor = null;
                             
                             if (name.includes('body') || name.includes('head') || name.includes('face') || name.includes('skin')) {
                                 naturalColor = new THREE.Color(0xfdbcb4); // 自然な肌色
                             } else if (name.includes('hair')) {
                                 naturalColor = new THREE.Color(0x8b4513); // ブラウン系の髪色
                             } else if (name.includes('shirt') || name.includes('top') || name.includes('cloth')) {
                                 naturalColor = new THREE.Color(0x87ceeb); // スカイブルー
                             } else if (name.includes('pants') || name.includes('bottom') || name.includes('leg')) {
                                 naturalColor = new THREE.Color(0x4682b4); // スチールブルー
                             } else {
                                 // その他の部位は元のグレーを少し暖色系に
                                 naturalColor = new THREE.Color(color.r * 1.1, color.g * 1.05, color.b * 0.95);
                             }
                             
                             if (naturalColor) {
                                 child.material.color.copy(naturalColor);
                                 console.log('✅ 自然な色に変更:', child.name, '#' + naturalColor.getHexString());
                             }
                         }
                         
                         console.log('Material details:', {
                             name: child.name,
                             type: child.material.type,
                             color: child.material.color,
                             map: child.material.map,
                             normalMap: child.material.normalMap,
                             roughness: child.material.roughness,
                             metalness: child.material.metalness
                         });
                     }
                 });
                 
                 scene.add(model);
                 window.currentModel = model; // グローバルに保存してカメラ制御用
                 
                 // 腕のボーン情報を保存
                 setupArmBones(model);

                // アニメーション設定
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    currentActions = [];
                    
                    gltf.animations.forEach((clip, index) => {
                        console.log(`=== アニメーション情報 ${index} ===`);
                        console.log('アニメーション名:', clip.name);
                        console.log('アニメーション時間:', clip.duration, '秒');
                        console.log('トラック数:', clip.tracks.length);
                        
                        // 各トラックの詳細情報
                        clip.tracks.forEach((track, trackIndex) => {
                            console.log(`  トラック ${trackIndex}: ${track.name}`);
                            console.log(`    キーフレーム数: ${track.times.length}`);
                        });
                        
                        const action = mixer.clipAction(clip);
                        action.play();
                        currentActions.push(action);
                    });
                    
                    console.log('=== アニメーション設定完了 ===');
                    console.log('総アニメーション数:', gltf.animations.length);
                } else {
                    console.log('No animations found in the model');
                }

                model.position.set(0, 0, 0);
                model.scale.set(1, 1, 1);
                console.log("モデル読み込み成功 - アニメーション数:", gltf.animations.length);
                
                 // ローディング表示を非表示、コントロールを表示
                 document.getElementById('loading').style.display = 'none';
                 document.getElementById('controls').style.display = 'block';
                 
                 // 初期設定：正面ビューを適用
                 setFrontView();
                
            }, function (progress) {
                if (progress.total > 0) {
                    const percent = Math.round((progress.loaded / progress.total * 100));
                    document.getElementById('loading').innerHTML = `Loading model... ${percent}%`;
                    console.log('Loading progress:', percent + '%');
                }
            }, function (error) {
                console.error("モデル読み込みエラー:", error);
                document.getElementById('loading').innerHTML = 'Error loading model: ' + error.message;
            });

            // リサイズ対応
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // アニメーションループ開始
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);
        }
        
         // 初期化開始
         init();
         
         // カメラ制御関数
         window.setFrontView = function() {
             if (window.currentModel) {
                 camera.position.set(0, 1, 3);
                 camera.lookAt(0, 1, 0);
             }
         }
         
         window.setSideView = function() {
             if (window.currentModel) {
                 camera.position.set(3, 1, 0);
                 camera.lookAt(0, 1, 0);
             }
         }
         
         window.setBackView = function() {
             if (window.currentModel) {
                 camera.position.set(0, 1, -3);
                 camera.lookAt(0, 1, 0);
             }
         }
         
         
         // ========== フラット化処理関数群 ==========
         
         // トゥーン風効果 - 彩度・コントラスト強調アプローチ（改良版）
         window.toggleToonShading = function() {
             flatEffects.toonShading = !flatEffects.toonShading;
             const btn = document.getElementById('toonBtn');
             btn.textContent = `トゥーン風効果: ${flatEffects.toonShading ? 'ON' : 'OFF'}`;
             
             if (window.currentModel) {
                 window.currentModel.traverse(function (child) {
                     if (child.isMesh && child.material) {
                         if (flatEffects.toonShading) {
                             // 元の色が存在しない場合はスキップ
                             if (!child.material.color) {
                                 console.log('Skipping mesh without color:', child.name);
                                 return;
                             }
                             const originalColor = child.material.color.clone();
                             
                             // アプローチ1: 彩度とコントラストを強調
                             const enhanceColor = (color) => {
                                 const hsl = {};
                                 color.getHSL(hsl);
                                 
                                 // 彩度を大幅に上げる（アニメ風の鮮やかな色）
                                 hsl.s = Math.min(1.0, hsl.s * 2.5);
                                 
                                 // コントラストを強調（明るい色はより明るく、暗い色はより暗く）
                                 if (hsl.l > 0.5) {
                                     hsl.l = Math.min(1.0, hsl.l * 1.3); // 明るい色をより明るく
                                 } else {
                                     hsl.l = Math.max(0.1, hsl.l * 0.7); // 暗い色をより暗く
                                 }
                                 
                                 color.setHSL(hsl.h, hsl.s, hsl.l);
                                 return color;
                             };
                             
                             // アプローチ2: 部位ごとに異なる色調を適用（アニメキャラ風）
                             const applyAnimeLikeColors = (color, meshName) => {
                                 const name = meshName.toLowerCase();
                                 
                                 // 肌色系の部位
                                 if (name.includes('body') || name.includes('head') || name.includes('face') || name.includes('skin')) {
                                     return new THREE.Color(0xffdbac); // アニメ風の肌色
                                 }
                                 // 髪の部位
                                 else if (name.includes('hair')) {
                                     return new THREE.Color(0x8b4513); // ブラウン系の髪色
                                 }
                                 // 服の部位
                                 else if (name.includes('shirt') || name.includes('top') || name.includes('cloth')) {
                                     return new THREE.Color(0x4169e1); // 鮮やかなブルー
                                 }
                                 // パンツ・ボトムス
                                 else if (name.includes('pants') || name.includes('bottom') || name.includes('leg')) {
                                     return new THREE.Color(0x2f4f4f); // ダークグレー
                                 }
                                 // その他
                                 else {
                                     return enhanceColor(color.clone());
                                 }
                             };
                             
                             const toonMaterial = new THREE.MeshBasicMaterial({
                                 color: applyAnimeLikeColors(originalColor, child.name || ''),
                                 transparent: child.material.transparent || false,
                                 opacity: child.material.opacity || 1.0
                             });
                             
                             child.material = toonMaterial;
                             console.log(`Applied anime-like color to: ${child.name}, Color:`, toonMaterial.color);
                         } else {
                             // 元のマテリアルに戻す
                             if (window.originalMaterials && window.originalMaterials.has(child)) {
                                 child.material = window.originalMaterials.get(child).clone();
                                 if (child.material.isMeshStandardMaterial) {
                                     child.material.roughness = 1.0;
                                     child.material.metalness = 0.0;
                                 }
                             }
                         }
                     }
                 });
             }
         }
         
         
         // ピクセル化効果（ローファイ・レトロゲーム風）
         window.togglePixelation = function() {
             flatEffects.pixelation = !flatEffects.pixelation;
             const btn = document.getElementById('pixelBtn');
             btn.textContent = `ピクセル化: ${flatEffects.pixelation ? 'ON' : 'OFF'}`;
             
             if (flatEffects.pixelation) {
                 // より強いピクセル化：解像度を1/8に下げる
                 const pixelRatio = 0.1; // より粗いピクセル
                 renderer.setSize(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
                 
                 // ピクセル化の見た目を強化
                 renderer.domElement.style.imageRendering = 'pixelated';
                 renderer.domElement.style.imageRendering = '-moz-crisp-edges';
                 renderer.domElement.style.imageRendering = 'crisp-edges';
                 renderer.domElement.style.width = window.innerWidth + 'px';
                 renderer.domElement.style.height = window.innerHeight + 'px';
                 
                 // アンチエイリアスを無効化してよりシャープなピクセルに
                 renderer.antialias = false;
                 
                 // 色数も制限してレトロ感を強化
                 if (window.currentModel) {
                     window.currentModel.traverse(function (child) {
                         if (child.isMesh && child.material && child.material.color) {
                             const color = child.material.color;
                             // 色を4段階に量子化（より強い制限）
                             const quantize = (value) => Math.floor(value * 4) / 4;
                             color.r = quantize(color.r);
                             color.g = quantize(color.g);
                             color.b = quantize(color.b);
                         }
                     });
                 }
             } else {
                 // 元の解像度と設定に戻す
                 renderer.setSize(window.innerWidth, window.innerHeight);
                 renderer.domElement.style.imageRendering = 'auto';
                 renderer.domElement.style.width = '';
                 renderer.domElement.style.height = '';
                 renderer.antialias = true;
                 
                 // 元の色に戻す
                 if (window.currentModel && window.originalMaterials) {
                     window.currentModel.traverse(function (child) {
                         if (child.isMesh && window.originalMaterials.has(child)) {
                             const originalColor = window.originalMaterials.get(child).color;
                             child.material.color.copy(originalColor);
                         }
                     });
                 }
             }
         }
         
         
         // ピクセル化トランジション（CSS移動時に適用）
         window.enablePixelTransition = function() {
             const canvas = renderer.domElement;
             
             // パフォーマンス測定開始
             const startTime = performance.now();
             
             console.log('=== ピクセル化パフォーマンス分析 ===');
             console.log('開始時刻:', startTime);
             
             // CSSトランジション対応のピクセル化
             const applyPixelTransition = () => {
                 // 一時的にピクセル化を適用
                 const pixelRatio = 0.1;
                 const originalWidth = window.innerWidth;
                 const originalHeight = window.innerHeight;
                 
                 // レンダラーサイズ変更（重い処理）
                 renderer.setSize(originalWidth * pixelRatio, originalHeight * pixelRatio);
                 
                 // CSS設定
                 canvas.style.imageRendering = 'pixelated';
                 canvas.style.width = originalWidth + 'px';
                 canvas.style.height = originalHeight + 'px';
                 canvas.style.transition = 'all 0.3s ease-in-out'; // トランジション追加
                 
                 // 色数制限も適用
                 if (window.currentModel) {
                     window.currentModel.traverse(function (child) {
                         if (child.isMesh && child.material && child.material.color) {
                             const color = child.material.color;
                             const quantize = (value) => Math.floor(value * 4) / 4;
                             color.r = quantize(color.r);
                             color.g = quantize(color.g);
                             color.b = quantize(color.b);
                         }
                     });
                 }
                 
                 const pixelTime = performance.now();
                 console.log('ピクセル化適用時間:', (pixelTime - startTime).toFixed(2), 'ms');
                 
                 // 2秒後に元に戻す（トランジション効果を確認）
                 setTimeout(() => {
                     renderer.setSize(originalWidth, originalHeight);
                     canvas.style.imageRendering = 'auto';
                     canvas.style.width = '';
                     canvas.style.height = '';
                     
                     // 元の色に戻す
                     if (window.currentModel && window.originalMaterials) {
                         window.currentModel.traverse(function (child) {
                             if (child.isMesh && window.originalMaterials.has(child)) {
                                 const originalColor = window.originalMaterials.get(child).color;
                                 child.material.color.copy(originalColor);
                             }
                         });
                     }
                     
                     const endTime = performance.now();
                     console.log('復元時間:', (endTime - pixelTime).toFixed(2), 'ms');
                     console.log('総処理時間:', (endTime - startTime).toFixed(2), 'ms');
                     
                     // パフォーマンス比較情報
                     console.log('=== パフォーマンス比較 ===');
                     console.log('ピクセル化処理: ~' + (pixelTime - startTime).toFixed(0) + 'ms');
                     console.log('CSS blur filter: ~1-5ms (参考値)');
                     console.log('結論: ピクセル化はCSS filterより重い処理');
                     console.log('リアルタイム使用: 30fps以下では厳しい可能性');
                     console.log('推奨: 静的な場面転換時のみ使用');
                 }, 2000);
             };
             
             applyPixelTransition();
         }
         
         // 全ての効果をリセット
         window.resetAllEffects = function() {
             // 全ての効果をOFFに
             if (flatEffects.toonShading) toggleToonShading();
             if (flatEffects.pixelation) togglePixelation();
         }
         
         // ========== ボーン設定関数 ==========
         
         // 腕のボーン情報を設定
         function setupArmBones(model) {
             model.traverse(function (child) {
                 if (child.isBone) {
                     const name = child.name.toLowerCase();
                     if (name.includes('leftshoulder')) {
                         armBones.leftShoulder = child;
                     } else if (name.includes('leftarm') && !name.includes('forearm')) {
                         armBones.leftArm = child;
                     } else if (name.includes('leftforearm')) {
                         armBones.leftForeArm = child;
                     } else if (name.includes('rightshoulder')) {
                         armBones.rightShoulder = child;
                     } else if (name.includes('rightarm') && !name.includes('forearm')) {
                         armBones.rightArm = child;
                     } else if (name.includes('rightforearm')) {
                         armBones.rightForeArm = child;
                     }
                 }
             });
             
             console.log('=== ボーン設定完了 ===');
             console.log('左肩:', armBones.leftShoulder ? '✅' : '❌');
             console.log('左腕:', armBones.leftArm ? '✅' : '❌');
             console.log('左前腕:', armBones.leftForeArm ? '✅' : '❌');
             console.log('右肩:', armBones.rightShoulder ? '✅' : '❌');
             console.log('右腕:', armBones.rightArm ? '✅' : '❌');
             console.log('右前腕:', armBones.rightForeArm ? '✅' : '❌');
         }
         
         // ========== アニメーション制御関数群 ==========
         
         // アニメーションの再生・停止切り替え
         window.toggleAnimation = function() {
             isAnimationPlaying = !isAnimationPlaying;
             const btn = event.target;
             btn.textContent = `アニメーション: ${isAnimationPlaying ? 'ON' : 'OFF'}`;
             
             if (currentActions.length > 0) {
                 currentActions.forEach(action => {
                     if (isAnimationPlaying) {
                         action.play();
                     } else {
                         action.stop();
                     }
                 });
                 console.log(`アニメーション ${isAnimationPlaying ? '再生' : '停止'}`);
             }
         }
         
         // モデルの詳細分析
         window.analyzeModel = function() {
             if (!window.currentModel) {
                 console.log('モデルが読み込まれていません');
                 return;
             }
             
             console.log('=== モデル詳細分析 ===');
             
             // スケルトン（ボーン）構造の分析
             let boneCount = 0;
             let meshCount = 0;
             const boneNames = [];
             const meshNames = [];
             
             window.currentModel.traverse(function (child) {
                 if (child.isBone) {
                     boneCount++;
                     boneNames.push(child.name);
                     console.log(`ボーン: ${child.name}`);
                 }
                 if (child.isMesh) {
                     meshCount++;
                     meshNames.push(child.name);
                 }
             });
             
             console.log('=== 統計情報 ===');
             console.log('総ボーン数:', boneCount);
             console.log('総メッシュ数:', meshCount);
             console.log('ボーン一覧:', boneNames);
             console.log('メッシュ一覧:', meshNames);
             
             // アニメーション情報
             if (mixer) {
                 console.log('=== アニメーション情報 ===');
                 console.log('アニメーションミキサー:', mixer);
                 console.log('アクティブアクション数:', currentActions.length);
             }
             
             // ポーズ制御可能性の判定
             console.log('=== ポーズ制御可能性 ===');
             if (boneCount > 0) {
                 console.log('✅ ボーン構造が存在します - ポーズ制御可能');
                 console.log('✅ 腕の動きを制御できる可能性があります');
             } else {
                 console.log('❌ ボーン構造が見つかりません - ポーズ制御不可');
                 console.log('❌ 別のGLBファイルまたはBlenderでの編集が必要');
             }
         }
         
         // ポーズ制御テスト
         window.testPoseControl = function() {
             if (!window.currentModel) {
                 console.log('モデルが読み込まれていません');
                 return;
             }
             
             console.log('=== ポーズ制御テスト ===');
             
             // 腕のボーンを探す
             const armBones = [];
             window.currentModel.traverse(function (child) {
                 if (child.isBone) {
                     const name = child.name.toLowerCase();
                     if (name.includes('arm') || name.includes('shoulder') || name.includes('elbow') || name.includes('wrist')) {
                         armBones.push(child);
                         console.log(`腕関連ボーン発見: ${child.name}`);
                     }
                 }
             });
             
             if (armBones.length > 0) {
                 console.log('✅ 腕のボーンが見つかりました - ポーズ制御テスト実行');
                 
                 // 簡単な腕の回転テスト
                 armBones.forEach(bone => {
                     if (bone.name.toLowerCase().includes('shoulder')) {
                         console.log(`テスト: ${bone.name}を回転`);
                         // 腕を少し上げる
                         bone.rotation.x += 0.5; // 45度程度上げる
                     }
                 });
                 
                 // 3秒後に元に戻す
                 setTimeout(() => {
                     armBones.forEach(bone => {
                         if (bone.name.toLowerCase().includes('shoulder')) {
                             bone.rotation.x -= 0.5;
                         }
                     });
                     console.log('ポーズ制御テスト完了 - 元の姿勢に戻しました');
                 }, 3000);
                 
             } else {
                 console.log('❌ 腕のボーンが見つかりません');
                 console.log('❌ このモデルでは腕のポーズ制御は困難です');
             }
         }
         
         // ========== ポーズ制御関数群 ==========
         
         // ポーズをリセット
         window.resetPose = function() {
             // 全てのボーンの回転をリセット
             Object.values(armBones).forEach(bone => {
                 if (bone) {
                     bone.rotation.set(0, 0, 0);
                 }
             });
             console.log('ポーズをリセットしました');
         }
         
         // 左腕を上げる
         window.raiseLeftArm = function() {
             if (armBones.leftShoulder) {
                 armBones.leftShoulder.rotation.x = -Math.PI / 2; // -90度（上に上げる）
                 console.log('左腕を上げました');
             }
         }
         
         // 右腕を上げる
         window.raiseRightArm = function() {
             if (armBones.rightShoulder) {
                 armBones.rightShoulder.rotation.x = -Math.PI / 2; // -90度（上に上げる）
                 console.log('右腕を上げました');
             }
         }
         
         // 両腕を上げる
         window.raiseBothArms = function() {
             raiseLeftArm();
             raiseRightArm();
             console.log('両腕を上げました');
         }
         
         // 左腕を振る（ウェーブ）
         window.waveLeftArm = function() {
             if (armBones.leftShoulder) {
                 armBones.leftShoulder.rotation.x = -Math.PI / 3; // -60度
                 armBones.leftShoulder.rotation.z = Math.PI / 4;  // 45度横に
                 console.log('左腕を振りました');
                 
                 // 2秒後に元に戻す
                 setTimeout(() => {
                     armBones.leftShoulder.rotation.set(0, 0, 0);
                     console.log('左腕を元に戻しました');
                 }, 2000);
             }
         }
         
         // 右腕を振る（ウェーブ）
         window.waveRightArm = function() {
             if (armBones.rightShoulder) {
                 armBones.rightShoulder.rotation.x = -Math.PI / 3; // -60度
                 armBones.rightShoulder.rotation.z = -Math.PI / 4; // -45度横に
                 console.log('右腕を振りました');
                 
                 // 2秒後に元に戻す
                 setTimeout(() => {
                     armBones.rightShoulder.rotation.set(0, 0, 0);
                     console.log('右腕を元に戻しました');
                 }, 2000);
             }
         }
         
         // 画面にフィット（正面ビューと同じ設定を適用）
         window.fitToScreen = function() {
             if (window.currentModel) {
                 // 正面ビューと同じ設定を使用
                 setFrontView();
                 console.log('fitToScreen: Applied front view settings');
             }
         }
     </script>
</body>
</html>
